// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: folders.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (name, owner_id, parent_folder_id, is_root)
VALUES ($1, $2, $3, $4)
RETURNING id, name, owner_id, parent_folder_id, is_root, status, is_starred, created_at, updated_at, trashed_at
`

type CreateFolderParams struct {
	Name           string      `json:"name"`
	OwnerID        pgtype.UUID `json:"owner_id"`
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
	IsRoot         pgtype.Bool `json:"is_root"`
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, createFolder,
		arg.Name,
		arg.OwnerID,
		arg.ParentFolderID,
		arg.IsRoot,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.ParentFolderID,
		&i.IsRoot,
		&i.Status,
		&i.IsStarred,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrashedAt,
	)
	return i, err
}

const getFolderByID = `-- name: GetFolderByID :one
SELECT id, name, owner_id, parent_folder_id, is_root, status, is_starred, created_at, updated_at, trashed_at FROM folders WHERE id = $1 AND status = 'active'
`

func (q *Queries) GetFolderByID(ctx context.Context, id pgtype.UUID) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolderByID, id)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.ParentFolderID,
		&i.IsRoot,
		&i.Status,
		&i.IsStarred,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrashedAt,
	)
	return i, err
}

const getFoldersByOwner = `-- name: GetFoldersByOwner :many
SELECT id, name, owner_id, parent_folder_id, is_root, status, is_starred, created_at, updated_at, trashed_at FROM folders
WHERE owner_id = $1 AND status = 'active'
ORDER BY name ASC
`

func (q *Queries) GetFoldersByOwner(ctx context.Context, ownerID pgtype.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.IsRoot,
			&i.Status,
			&i.IsStarred,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootFolder = `-- name: GetRootFolder :one
SELECT id, name, owner_id, parent_folder_id, is_root, status, is_starred, created_at, updated_at, trashed_at FROM folders
WHERE owner_id = $1 AND is_root = TRUE
LIMIT 1
`

func (q *Queries) GetRootFolder(ctx context.Context, ownerID pgtype.UUID) (Folder, error) {
	row := q.db.QueryRow(ctx, getRootFolder, ownerID)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.ParentFolderID,
		&i.IsRoot,
		&i.Status,
		&i.IsStarred,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrashedAt,
	)
	return i, err
}

const getRootFolders = `-- name: GetRootFolders :many
SELECT id, name, owner_id, parent_folder_id, is_root, status, is_starred, created_at, updated_at, trashed_at FROM folders
WHERE owner_id = $1
  AND parent_folder_id IS NULL
  AND is_root = FALSE
  AND status = 'active'
ORDER BY name ASC
`

func (q *Queries) GetRootFolders(ctx context.Context, ownerID pgtype.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, getRootFolders, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.IsRoot,
			&i.Status,
			&i.IsStarred,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubfolders = `-- name: GetSubfolders :many
SELECT id, name, owner_id, parent_folder_id, is_root, status, is_starred, created_at, updated_at, trashed_at FROM folders
WHERE parent_folder_id = $1 AND status = 'active'
ORDER BY name ASC
`

func (q *Queries) GetSubfolders(ctx context.Context, parentFolderID pgtype.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, getSubfolders, parentFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.IsRoot,
			&i.Status,
			&i.IsStarred,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const renameFolder = `-- name: RenameFolder :exec
UPDATE folders
SET name = $2, updated_at = NOW()
WHERE id = $1
`

type RenameFolderParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) RenameFolder(ctx context.Context, arg RenameFolderParams) error {
	_, err := q.db.Exec(ctx, renameFolder, arg.ID, arg.Name)
	return err
}

const restoreFolder = `-- name: RestoreFolder :exec
UPDATE folders
SET parent_folder_id = $2, updated_at = NOW()
WHERE id = $1
`

type MoveFolderParams struct {
	ID             pgtype.UUID `json:"id"`
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
}

func (q *Queries) MoveFolder(ctx context.Context, arg MoveFolderParams) error {
	_, err := q.db.Exec(ctx, moveFolder, arg.ID, arg.ParentFolderID)
	return err
}

const renameFolder = `-- name: RenameFolder :exec
UPDATE folders
SET name = $2, updated_at = NOW()
WHERE id = $1
`

type RenameFolderParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) RenameFolder(ctx context.Context, arg RenameFolderParams) error {
	_, err := q.db.Exec(ctx, renameFolder, arg.ID, arg.Name)
	return err
}
