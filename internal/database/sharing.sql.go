// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sharing.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (item_type, item_id, user_id, role, granted_by)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (item_type, item_id, user_id)
DO UPDATE SET role = EXCLUDED.role
RETURNING id, item_type, item_id, user_id, role, granted_by, created_at
`

type CreatePermissionParams struct {
	ItemType  ItemType       `json:"item_type"`
	ItemID    pgtype.UUID    `json:"item_id"`
	UserID    pgtype.UUID    `json:"user_id"`
	Role      PermissionRole `json:"role"`
	GrantedBy pgtype.UUID    `json:"granted_by"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, createPermission,
		arg.ItemType,
		arg.ItemID,
		arg.UserID,
		arg.Role,
		arg.GrantedBy,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ItemID,
		&i.UserID,
		&i.Role,
		&i.GrantedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createShare = `-- name: CreateShare :one
INSERT INTO shares (item_type, item_id, token, created_by, permission, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, item_type, item_id, token, created_by, permission, expires_at, is_active, created_at
`

type CreateShareParams struct {
	ItemType   ItemType           `json:"item_type"`
	ItemID     pgtype.UUID        `json:"item_id"`
	Token      string             `json:"token"`
	CreatedBy  pgtype.UUID        `json:"created_by"`
	Permission NullPermissionRole `json:"permission"`
	ExpiresAt  pgtype.Timestamp   `json:"expires_at"`
}

func (q *Queries) CreateShare(ctx context.Context, arg CreateShareParams) (Share, error) {
	row := q.db.QueryRow(ctx, createShare,
		arg.ItemType,
		arg.ItemID,
		arg.Token,
		arg.CreatedBy,
		arg.Permission,
		arg.ExpiresAt,
	)
	var i Share
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ItemID,
		&i.Token,
		&i.CreatedBy,
		&i.Permission,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateShare = `-- name: DeactivateShare :exec
UPDATE shares SET is_active = FALSE WHERE id = $1
`

func (q *Queries) DeactivateShare(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateShare, id)
	return err
}

const getItemPermissions = `-- name: GetItemPermissions :many
SELECT p.id, p.item_type, p.item_id, p.user_id, p.role, p.granted_by, p.created_at, u.email, u.name as user_name
FROM permissions p
JOIN users u ON p.user_id = u.id
WHERE p.item_type = $1 AND p.item_id = $2
`

type GetItemPermissionsParams struct {
	ItemType ItemType    `json:"item_type"`
	ItemID   pgtype.UUID `json:"item_id"`
}

type GetItemPermissionsRow struct {
	ID        pgtype.UUID      `json:"id"`
	ItemType  ItemType         `json:"item_type"`
	ItemID    pgtype.UUID      `json:"item_id"`
	UserID    pgtype.UUID      `json:"user_id"`
	Role      PermissionRole   `json:"role"`
	GrantedBy pgtype.UUID      `json:"granted_by"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	Email     string           `json:"email"`
	UserName  string           `json:"user_name"`
}

func (q *Queries) GetItemPermissions(ctx context.Context, arg GetItemPermissionsParams) ([]GetItemPermissionsRow, error) {
	rows, err := q.db.Query(ctx, getItemPermissions, arg.ItemType, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetItemPermissionsRow{}
	for rows.Next() {
		var i GetItemPermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ItemID,
			&i.UserID,
			&i.Role,
			&i.GrantedBy,
			&i.CreatedAt,
			&i.Email,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShareByToken = `-- name: GetShareByToken :one
SELECT id, item_type, item_id, token, created_by, permission, expires_at, is_active, created_at FROM shares WHERE token = $1 AND is_active = TRUE
`

func (q *Queries) GetShareByToken(ctx context.Context, token string) (Share, error) {
	row := q.db.QueryRow(ctx, getShareByToken, token)
	var i Share
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ItemID,
		&i.Token,
		&i.CreatedBy,
		&i.Permission,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getSharedWithMeFiles = `-- name: GetSharedWithMeFiles :many
SELECT f.id, f.name, f.original_name, f.mime_type, f.size, f.storage_path, f.owner_id, f.parent_folder_id, f.status, f.is_starred, f.thumbnail_path, f.preview_available, f.version, f.current_version_id, f.created_at, f.updated_at, f.trashed_at, f.last_accessed_at, u.name as owner_name, p.role
FROM files f
JOIN permissions p ON p.item_type = 'file' AND p.item_id = f.id
JOIN users u ON f.owner_id = u.id
WHERE p.user_id = $1 AND f.status = 'active'
`

type GetSharedWithMeFilesRow struct {
	ID               pgtype.UUID      `json:"id"`
	Name             string           `json:"name"`
	OriginalName     string           `json:"original_name"`
	MimeType         string           `json:"mime_type"`
	Size             int64            `json:"size"`
	StoragePath      string           `json:"storage_path"`
	OwnerID          pgtype.UUID      `json:"owner_id"`
	ParentFolderID   pgtype.UUID      `json:"parent_folder_id"`
	Status           NullFileStatus   `json:"status"`
	IsStarred        pgtype.Bool      `json:"is_starred"`
	ThumbnailPath    pgtype.Text      `json:"thumbnail_path"`
	PreviewAvailable pgtype.Bool      `json:"preview_available"`
	Version          pgtype.Int4      `json:"version"`
	CurrentVersionID pgtype.UUID      `json:"current_version_id"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	TrashedAt        pgtype.Timestamp `json:"trashed_at"`
	LastAccessedAt   pgtype.Timestamp `json:"last_accessed_at"`
	OwnerName        string           `json:"owner_name"`
	Role             PermissionRole   `json:"role"`
}

func (q *Queries) GetSharedWithMeFiles(ctx context.Context, userID pgtype.UUID) ([]GetSharedWithMeFilesRow, error) {
	rows, err := q.db.Query(ctx, getSharedWithMeFiles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSharedWithMeFilesRow{}
	for rows.Next() {
		var i GetSharedWithMeFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
			&i.OwnerName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedWithMeFolders = `-- name: GetSharedWithMeFolders :many
SELECT fo.id, fo.name, fo.owner_id, fo.parent_folder_id, fo.is_root, fo.status, fo.is_starred, fo.created_at, fo.updated_at, fo.trashed_at, u.name as owner_name, p.role
FROM folders fo
JOIN permissions p ON p.item_type = 'folder' AND p.item_id = fo.id
JOIN users u ON fo.owner_id = u.id
WHERE p.user_id = $1 AND fo.status = 'active'
`

type GetSharedWithMeFoldersRow struct {
	ID             pgtype.UUID      `json:"id"`
	Name           string           `json:"name"`
	OwnerID        pgtype.UUID      `json:"owner_id"`
	ParentFolderID pgtype.UUID      `json:"parent_folder_id"`
	IsRoot         pgtype.Bool      `json:"is_root"`
	Status         NullFileStatus   `json:"status"`
	IsStarred      pgtype.Bool      `json:"is_starred"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	TrashedAt      pgtype.Timestamp `json:"trashed_at"`
	OwnerName      string           `json:"owner_name"`
	Role           PermissionRole   `json:"role"`
}

func (q *Queries) GetSharedWithMeFolders(ctx context.Context, userID pgtype.UUID) ([]GetSharedWithMeFoldersRow, error) {
	rows, err := q.db.Query(ctx, getSharedWithMeFolders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSharedWithMeFoldersRow{}
	for rows.Next() {
		var i GetSharedWithMeFoldersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.IsRoot,
			&i.Status,
			&i.IsStarred,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.OwnerName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharesByItem = `-- name: GetSharesByItem :many
SELECT id, item_type, item_id, token, created_by, permission, expires_at, is_active, created_at FROM shares WHERE item_type = $1 AND item_id = $2 AND is_active = TRUE
`

type GetSharesByItemParams struct {
	ItemType ItemType    `json:"item_type"`
	ItemID   pgtype.UUID `json:"item_id"`
}

func (q *Queries) GetSharesByItem(ctx context.Context, arg GetSharesByItemParams) ([]Share, error) {
	rows, err := q.db.Query(ctx, getSharesByItem, arg.ItemType, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Share{}
	for rows.Next() {
		var i Share
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ItemID,
			&i.Token,
			&i.CreatedBy,
			&i.Permission,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissionForItem = `-- name: GetUserPermissionForItem :one
SELECT id, item_type, item_id, user_id, role, granted_by, created_at FROM permissions
WHERE item_type = $1 AND item_id = $2 AND user_id = $3
`

type GetUserPermissionForItemParams struct {
	ItemType ItemType    `json:"item_type"`
	ItemID   pgtype.UUID `json:"item_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetUserPermissionForItem(ctx context.Context, arg GetUserPermissionForItemParams) (Permission, error) {
	row := q.db.QueryRow(ctx, getUserPermissionForItem, arg.ItemType, arg.ItemID, arg.UserID)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ItemID,
		&i.UserID,
		&i.Role,
		&i.GrantedBy,
		&i.CreatedAt,
	)
	return i, err
}

const revokePermission = `-- name: RevokePermission :exec
DELETE FROM permissions
WHERE item_type = $1 AND item_id = $2 AND user_id = $3
`

type RevokePermissionParams struct {
	ItemType ItemType    `json:"item_type"`
	ItemID   pgtype.UUID `json:"item_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

func (q *Queries) RevokePermission(ctx context.Context, arg RevokePermissionParams) error {
	_, err := q.db.Exec(ctx, revokePermission, arg.ItemType, arg.ItemID, arg.UserID)
	return err
}
