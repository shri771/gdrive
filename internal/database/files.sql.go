// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    name, original_name, mime_type, size, storage_path,
    owner_id, parent_folder_id, preview_available, thumbnail_path
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at
`

type CreateFileParams struct {
	Name             string      `json:"name"`
	OriginalName     string      `json:"original_name"`
	MimeType         string      `json:"mime_type"`
	Size             int64       `json:"size"`
	StoragePath      string      `json:"storage_path"`
	OwnerID          pgtype.UUID `json:"owner_id"`
	ParentFolderID   pgtype.UUID `json:"parent_folder_id"`
	PreviewAvailable pgtype.Bool `json:"preview_available"`
	ThumbnailPath    pgtype.Text `json:"thumbnail_path"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.Name,
		arg.OriginalName,
		arg.MimeType,
		arg.Size,
		arg.StoragePath,
		arg.OwnerID,
		arg.ParentFolderID,
		arg.PreviewAvailable,
		arg.ThumbnailPath,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalName,
		&i.MimeType,
		&i.Size,
		&i.StoragePath,
		&i.OwnerID,
		&i.ParentFolderID,
		&i.Status,
		&i.IsStarred,
		&i.ThumbnailPath,
		&i.PreviewAvailable,
		&i.Version,
		&i.CurrentVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrashedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files WHERE id = $1 AND status = 'active'
`

func (q *Queries) GetFileByID(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalName,
		&i.MimeType,
		&i.Size,
		&i.StoragePath,
		&i.OwnerID,
		&i.ParentFolderID,
		&i.Status,
		&i.IsStarred,
		&i.ThumbnailPath,
		&i.PreviewAvailable,
		&i.Version,
		&i.CurrentVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrashedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getFileByIDAnyStatus = `-- name: GetFileByIDAnyStatus :one
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files WHERE id = $1
`

func (q *Queries) GetFileByIDAnyStatus(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByIDAnyStatus, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalName,
		&i.MimeType,
		&i.Size,
		&i.StoragePath,
		&i.OwnerID,
		&i.ParentFolderID,
		&i.Status,
		&i.IsStarred,
		&i.ThumbnailPath,
		&i.PreviewAvailable,
		&i.Version,
		&i.CurrentVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrashedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getFileByNameAndFolder = `-- name: GetFileByNameAndFolder :one
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1
  AND name = $2
  AND (parent_folder_id = $3 OR (parent_folder_id IS NULL AND $3 IS NULL))
  AND status = 'active'
LIMIT 1
`

type GetFileByNameAndFolderParams struct {
	OwnerID        pgtype.UUID `json:"owner_id"`
	Name           string      `json:"name"`
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
}

func (q *Queries) GetFileByNameAndFolder(ctx context.Context, arg GetFileByNameAndFolderParams) (File, error) {
	row := q.db.QueryRow(ctx, getFileByNameAndFolder, arg.OwnerID, arg.Name, arg.ParentFolderID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalName,
		&i.MimeType,
		&i.Size,
		&i.StoragePath,
		&i.OwnerID,
		&i.ParentFolderID,
		&i.Status,
		&i.IsStarred,
		&i.ThumbnailPath,
		&i.PreviewAvailable,
		&i.Version,
		&i.CurrentVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrashedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getFilesByFolder = `-- name: GetFilesByFolder :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1
  AND parent_folder_id = $2
  AND status = 'active'
ORDER BY created_at DESC
`

type GetFilesByFolderParams struct {
	OwnerID        pgtype.UUID `json:"owner_id"`
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
}

func (q *Queries) GetFilesByFolder(ctx context.Context, arg GetFilesByFolderParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByFolder, arg.OwnerID, arg.ParentFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByOwner = `-- name: GetFilesByOwner :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1 AND status = 'active'
ORDER BY updated_at DESC
LIMIT $2 OFFSET $3
`

type GetFilesByOwnerParams struct {
	OwnerID pgtype.UUID `json:"owner_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) GetFilesByOwner(ctx context.Context, arg GetFilesByOwnerParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesInTrashOlderThan = `-- name: GetFilesInTrashOlderThan :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE status = 'trashed'
  AND trashed_at < NOW() - INTERVAL '1 day' * $1
ORDER BY trashed_at ASC
`

func (q *Queries) GetFilesInTrashOlderThan(ctx context.Context, dollar_1 interface{}) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesInTrashOlderThan, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFiles = `-- name: GetRecentFiles :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1 AND status = 'active'
ORDER BY last_accessed_at DESC NULLS LAST
LIMIT $2
`

type GetRecentFilesParams struct {
	OwnerID pgtype.UUID `json:"owner_id"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) GetRecentFiles(ctx context.Context, arg GetRecentFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getRecentFiles, arg.OwnerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootFiles = `-- name: GetRootFiles :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1
  AND parent_folder_id IS NULL
  AND status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) GetRootFiles(ctx context.Context, ownerID pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, getRootFiles, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStarredFiles = `-- name: GetStarredFiles :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1 AND is_starred = TRUE AND status = 'active'
ORDER BY updated_at DESC
`

func (q *Queries) GetStarredFiles(ctx context.Context, ownerID pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, getStarredFiles, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedFiles = `-- name: GetTrashedFiles :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1 AND status = 'trashed'
ORDER BY trashed_at DESC
`

func (q *Queries) GetTrashedFiles(ctx context.Context, ownerID pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, getTrashedFiles, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveFile = `-- name: MoveFile :exec
UPDATE files
SET parent_folder_id = $2, updated_at = NOW()
WHERE id = $1
`

type MoveFileParams struct {
	ID             pgtype.UUID `json:"id"`
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
}

func (q *Queries) MoveFile(ctx context.Context, arg MoveFileParams) error {
	_, err := q.db.Exec(ctx, moveFile, arg.ID, arg.ParentFolderID)
	return err
}

const permanentDeleteFile = `-- name: PermanentDeleteFile :exec
UPDATE files
SET status = 'deleted'
WHERE id = $1
`

func (q *Queries) PermanentDeleteFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, permanentDeleteFile, id)
	return err
}

const renameFile = `-- name: RenameFile :exec
UPDATE files
SET name = $2, updated_at = NOW()
WHERE id = $1
`

type RenameFileParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) RenameFile(ctx context.Context, arg RenameFileParams) error {
	_, err := q.db.Exec(ctx, renameFile, arg.ID, arg.Name)
	return err
}

const restoreFile = `-- name: RestoreFile :exec
UPDATE files
SET status = 'active', trashed_at = NULL
WHERE id = $1
`

func (q *Queries) RestoreFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, restoreFile, id)
	return err
}

const searchFilesByName = `-- name: SearchFilesByName :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1
  AND status = 'active'
  AND to_tsvector('english', name) @@ plainto_tsquery('english', $2)
ORDER BY updated_at DESC
LIMIT $3
`

type SearchFilesByNameParams struct {
	OwnerID        pgtype.UUID `json:"owner_id"`
	PlaintoTsquery string      `json:"plainto_tsquery"`
	Limit          int32       `json:"limit"`
}

func (q *Queries) SearchFilesByName(ctx context.Context, arg SearchFilesByNameParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchFilesByName, arg.OwnerID, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFilesByType = `-- name: SearchFilesByType :many
SELECT id, name, original_name, mime_type, size, storage_path, owner_id, parent_folder_id, status, is_starred, thumbnail_path, preview_available, version, current_version_id, created_at, updated_at, trashed_at, last_accessed_at FROM files
WHERE owner_id = $1
  AND status = 'active'
  AND mime_type LIKE $2 || '%'
ORDER BY updated_at DESC
`

type SearchFilesByTypeParams struct {
	OwnerID pgtype.UUID `json:"owner_id"`
	Column2 pgtype.Text `json:"column_2"`
}

func (q *Queries) SearchFilesByType(ctx context.Context, arg SearchFilesByTypeParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchFilesByType, arg.OwnerID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalName,
			&i.MimeType,
			&i.Size,
			&i.StoragePath,
			&i.OwnerID,
			&i.ParentFolderID,
			&i.Status,
			&i.IsStarred,
			&i.ThumbnailPath,
			&i.PreviewAvailable,
			&i.Version,
			&i.CurrentVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrashedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleStarFile = `-- name: ToggleStarFile :exec
UPDATE files
SET is_starred = NOT is_starred, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ToggleStarFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, toggleStarFile, id)
	return err
}

const trashFile = `-- name: TrashFile :exec
UPDATE files
SET status = 'trashed', trashed_at = NOW()
WHERE id = $1
`

func (q *Queries) TrashFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, trashFile, id)
	return err
}

const updateFileStorageAndVersion = `-- name: UpdateFileStorageAndVersion :exec
UPDATE files
SET storage_path = $2,
    size = $3,
    mime_type = $4,
    version = $5,
    current_version_id = $6,
    updated_at = NOW()
WHERE id = $1
`

type UpdateFileStorageAndVersionParams struct {
	ID               pgtype.UUID `json:"id"`
	StoragePath      string      `json:"storage_path"`
	Size             int64       `json:"size"`
	MimeType         string      `json:"mime_type"`
	Version          pgtype.Int4 `json:"version"`
	CurrentVersionID pgtype.UUID `json:"current_version_id"`
}

func (q *Queries) UpdateFileStorageAndVersion(ctx context.Context, arg UpdateFileStorageAndVersionParams) error {
	_, err := q.db.Exec(ctx, updateFileStorageAndVersion,
		arg.ID,
		arg.StoragePath,
		arg.Size,
		arg.MimeType,
		arg.Version,
		arg.CurrentVersionID,
	)
	return err
}

const updateLastAccessed = `-- name: UpdateLastAccessed :exec
UPDATE files
SET last_accessed_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateLastAccessed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateLastAccessed, id)
	return err
}
