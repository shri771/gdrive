// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActivityTimeline = `-- name: GetActivityTimeline :many
SELECT 
    DATE(al.created_at) as activity_date,
    al.id,
    al.user_id,
    al.file_id,
    al.activity_type,
    al.details,
    al.created_at,
    u.name as user_name,
    u.email as user_email,
    f.name as file_name,
    f.mime_type as file_mime_type
FROM activity_log al
JOIN users u ON al.user_id = u.id
LEFT JOIN files f ON al.file_id = f.id
WHERE al.user_id = $1
  AND DATE(al.created_at) >= $2::date
  AND DATE(al.created_at) <= $3::date
ORDER BY al.created_at DESC
`

type GetActivityTimelineParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 pgtype.Date `json:"column_2"`
	Column3 pgtype.Date `json:"column_3"`
}

type GetActivityTimelineRow struct {
	ActivityDate pgtype.Date      `json:"activity_date"`
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	FileID       pgtype.UUID      `json:"file_id"`
	ActivityType ActivityType     `json:"activity_type"`
	Details      []byte           `json:"details"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UserName     string           `json:"user_name"`
	UserEmail    string           `json:"user_email"`
	FileName     pgtype.Text      `json:"file_name"`
	FileMimeType pgtype.Text      `json:"file_mime_type"`
}

func (q *Queries) GetActivityTimeline(ctx context.Context, arg GetActivityTimelineParams) ([]GetActivityTimelineRow, error) {
	rows, err := q.db.Query(ctx, getActivityTimeline, arg.UserID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivityTimelineRow{}
	for rows.Next() {
		var i GetActivityTimelineRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.ID,
			&i.UserID,
			&i.FileID,
			&i.ActivityType,
			&i.Details,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
			&i.FileName,
			&i.FileMimeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardActivity = `-- name: GetDashboardActivity :many
SELECT 
    al.id, al.user_id, al.file_id, al.activity_type, al.details, al.created_at,
    u.name as user_name,
    u.email as user_email,
    f.name as file_name,
    f.mime_type as file_mime_type,
    f.size as file_size
FROM activity_log al
JOIN users u ON al.user_id = u.id
LEFT JOIN files f ON al.file_id = f.id
WHERE al.user_id = $1
ORDER BY al.created_at DESC
LIMIT $2
`

type GetDashboardActivityParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

type GetDashboardActivityRow struct {
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	FileID       pgtype.UUID      `json:"file_id"`
	ActivityType ActivityType     `json:"activity_type"`
	Details      []byte           `json:"details"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UserName     string           `json:"user_name"`
	UserEmail    string           `json:"user_email"`
	FileName     pgtype.Text      `json:"file_name"`
	FileMimeType pgtype.Text      `json:"file_mime_type"`
	FileSize     pgtype.Int8      `json:"file_size"`
}

func (q *Queries) GetDashboardActivity(ctx context.Context, arg GetDashboardActivityParams) ([]GetDashboardActivityRow, error) {
	rows, err := q.db.Query(ctx, getDashboardActivity, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDashboardActivityRow{}
	for rows.Next() {
		var i GetDashboardActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileID,
			&i.ActivityType,
			&i.Details,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
			&i.FileName,
			&i.FileMimeType,
			&i.FileSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileActivity = `-- name: GetFileActivity :many
SELECT al.id, al.user_id, al.file_id, al.activity_type, al.details, al.created_at, u.name as user_name
FROM activity_log al
JOIN users u ON al.user_id = u.id
WHERE al.file_id = $1
ORDER BY al.created_at DESC
LIMIT $2
`

type GetFileActivityParams struct {
	FileID pgtype.UUID `json:"file_id"`
	Limit  int32       `json:"limit"`
}

type GetFileActivityRow struct {
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	FileID       pgtype.UUID      `json:"file_id"`
	ActivityType ActivityType     `json:"activity_type"`
	Details      []byte           `json:"details"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UserName     string           `json:"user_name"`
}

func (q *Queries) GetFileActivity(ctx context.Context, arg GetFileActivityParams) ([]GetFileActivityRow, error) {
	rows, err := q.db.Query(ctx, getFileActivity, arg.FileID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFileActivityRow{}
	for rows.Next() {
		var i GetFileActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileID,
			&i.ActivityType,
			&i.Details,
			&i.CreatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivity = `-- name: GetUserActivity :many
SELECT al.id, al.user_id, al.file_id, al.activity_type, al.details, al.created_at, f.name as file_name
FROM activity_log al
LEFT JOIN files f ON al.file_id = f.id
WHERE al.user_id = $1
ORDER BY al.created_at DESC
LIMIT $2
`

type GetUserActivityParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

type GetUserActivityRow struct {
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	FileID       pgtype.UUID      `json:"file_id"`
	ActivityType ActivityType     `json:"activity_type"`
	Details      []byte           `json:"details"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	FileName     pgtype.Text      `json:"file_name"`
}

func (q *Queries) GetUserActivity(ctx context.Context, arg GetUserActivityParams) ([]GetUserActivityRow, error) {
	rows, err := q.db.Query(ctx, getUserActivity, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserActivityRow{}
	for rows.Next() {
		var i GetUserActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileID,
			&i.ActivityType,
			&i.Details,
			&i.CreatedAt,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logActivity = `-- name: LogActivity :exec
INSERT INTO activity_log (user_id, file_id, activity_type, details)
VALUES ($1, $2, $3, $4)
`

type LogActivityParams struct {
	UserID       pgtype.UUID  `json:"user_id"`
	FileID       pgtype.UUID  `json:"file_id"`
	ActivityType ActivityType `json:"activity_type"`
	Details      []byte       `json:"details"`
}

func (q *Queries) LogActivity(ctx context.Context, arg LogActivityParams) error {
	_, err := q.db.Exec(ctx, logActivity,
		arg.UserID,
		arg.FileID,
		arg.ActivityType,
		arg.Details,
	)
	return err
}
