// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFileActivity = `-- name: GetFileActivity :many
SELECT al.id, al.user_id, al.file_id, al.activity_type, al.details, al.created_at, u.name as user_name
FROM activity_log al
JOIN users u ON al.user_id = u.id
WHERE al.file_id = $1
ORDER BY al.created_at DESC
LIMIT $2
`

type GetFileActivityParams struct {
	FileID pgtype.UUID `json:"file_id"`
	Limit  int32       `json:"limit"`
}

type GetFileActivityRow struct {
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	FileID       pgtype.UUID      `json:"file_id"`
	ActivityType ActivityType     `json:"activity_type"`
	Details      []byte           `json:"details"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UserName     string           `json:"user_name"`
}

func (q *Queries) GetFileActivity(ctx context.Context, arg GetFileActivityParams) ([]GetFileActivityRow, error) {
	rows, err := q.db.Query(ctx, getFileActivity, arg.FileID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFileActivityRow{}
	for rows.Next() {
		var i GetFileActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileID,
			&i.ActivityType,
			&i.Details,
			&i.CreatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivity = `-- name: GetUserActivity :many
SELECT al.id, al.user_id, al.file_id, al.activity_type, al.details, al.created_at, f.name as file_name
FROM activity_log al
LEFT JOIN files f ON al.file_id = f.id
WHERE al.user_id = $1
ORDER BY al.created_at DESC
LIMIT $2
`

type GetUserActivityParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

type GetUserActivityRow struct {
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	FileID       pgtype.UUID      `json:"file_id"`
	ActivityType ActivityType     `json:"activity_type"`
	Details      []byte           `json:"details"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	FileName     pgtype.Text      `json:"file_name"`
}

func (q *Queries) GetUserActivity(ctx context.Context, arg GetUserActivityParams) ([]GetUserActivityRow, error) {
	rows, err := q.db.Query(ctx, getUserActivity, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserActivityRow{}
	for rows.Next() {
		var i GetUserActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileID,
			&i.ActivityType,
			&i.Details,
			&i.CreatedAt,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logActivity = `-- name: LogActivity :exec
INSERT INTO activity_log (user_id, file_id, activity_type, details)
VALUES ($1, $2, $3, $4)
`

type LogActivityParams struct {
	UserID       pgtype.UUID  `json:"user_id"`
	FileID       pgtype.UUID  `json:"file_id"`
	ActivityType ActivityType `json:"activity_type"`
	Details      []byte       `json:"details"`
}

func (q *Queries) LogActivity(ctx context.Context, arg LogActivityParams) error {
	_, err := q.db.Exec(ctx, logActivity,
		arg.UserID,
		arg.FileID,
		arg.ActivityType,
		arg.Details,
	)
	return err
}
